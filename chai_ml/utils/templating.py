# chai_ml/utils/templating.py
from typing import Any, Dict, List, Optional, Type, Union, get_origin, get_args
from pydantic import BaseModel, Field
import tiktoken
from datetime import datetime

def count_tokens(text: str, model: str = "gpt-4") -> int:
    """
    Count tokens in text for a specific model using tiktoken.

    Args:
        text (str): Text to tokenize.
        model (str): Model identifier for token counting.

    Returns:
        int: Number of tokens in the text.
    """
    try:
        encoding = tiktoken.encoding_for_model(model)
    except KeyError:
        # Fallback to cl100k_base encoding for unknown models
        encoding = tiktoken.get_encoding("cl100k_base")
    
    return len(encoding.encode(text))

def generate_json_template(model: Type[BaseModel]) -> Dict[str, Any]:
    """
    Generate a template JSON structure from a Pydantic model.

    Args:
        model (Type[BaseModel]): Pydantic model class.

    Returns:
        Dict[str, Any]: Template structure with placeholders and comments.
    """
    template = {}
    for field_name, field_info in model.model_fields.items():
        field_type = field_info.annotation
        description = field_info.description
        comment = f" # {description}" if description else ""

        # Handle Optional types
        if get_origin(field_type) is Union and type(None) in get_args(field_type):
            actual_type = next(arg for arg in get_args(field_type) if arg is not type(None))
            if get_origin(actual_type) is list or actual_type is list:
                template[field_name] = [f"<optional_list_item>{comment}"]
            else:
                template[field_name] = f"<optional_{_get_type_name(actual_type)}>{comment}"
        # Handle lists
        elif get_origin(field_type) is list or field_type is list:
            template[field_name] = [f"<list_item>{comment}"]
        # Handle basic types
        else:
            template[field_name] = f"<{_get_type_name(field_type)}>{comment}"

    return template

def _get_placeholder(field_type: Any, optional: bool = False) -> Any:
    """
    Get appropriate placeholder value for a field type.

    Args:
        field_type: Type annotation of the field.
        optional (bool): Whether the field is optional.

    Returns:
        Any: Appropriate placeholder value.
    """
    opt_prefix = "optional_" if optional else ""
    
    # Handle basic types
    if field_type == str:
        return f"<{opt_prefix}string>"
    elif field_type == int:
        return f"<{opt_prefix}int>"
    elif field_type == float:
        return f"<{opt_prefix}float>"
    elif field_type == bool:
        return f"<{opt_prefix}bool>"
    elif field_type == datetime:
        return f"<{opt_prefix}datetime>"
    
    # Handle lists
    origin = get_origin(field_type)
    if origin is list or origin is List:
        item_type = get_args(field_type)[0] if get_args(field_type) else Any
        return [f"<{opt_prefix}list_item_{_get_type_name(item_type)}>"]
    
    # Handle nested models
    if isinstance(field_type, type) and issubclass(field_type, BaseModel):
        return generate_json_template(field_type)
    
    # Handle dictionaries
    if origin is dict:
        key_type, value_type = get_args(field_type)
        return {f"<{opt_prefix}key_{_get_type_name(key_type)}>": 
                f"<{opt_prefix}value_{_get_type_name(value_type)}>"}
    
    # Handle unions (non-Optional)
    if origin is Union and type(None) not in get_args(field_type):
        types = [arg for arg in get_args(field_type) if arg is not type(None)]
        type_names = [_get_type_name(t) for t in types]
        return f"<{opt_prefix}union_{'+'.join(type_names)}>"
    
    # Default case
    return f"<{opt_prefix}value>"

def _get_type_name(type_: Any) -> str:
    """
    Get a string representation of a type for use in placeholders.

    Args:
        type_: The type to get a name for.

    Returns:
        str: String representation of the type.
    """
    if hasattr(type_, "__name__"):
        return type_.__name__.lower()
    elif get_origin(type_) is not None:
        origin = get_origin(type_)
        args = get_args(type_)
        origin_name = origin.__name__.lower()
        if args:
            arg_names = [_get_type_name(arg) for arg in args]
            return f"{origin_name}_of_{'_and_'.join(arg_names)}"
        return origin_name
    else:
        return "value"

def validate_template_compatibility(template: Dict[str, Any], data: Dict[str, Any]) -> bool:
    """
    Validate that provided data matches the structure defined in the template.

    Args:
        template (Dict[str, Any]): Template structure generated by generate_json_template.
        data (Dict[str, Any]): Data to validate against the template.

    Returns:
        bool: True if the data structure matches the template, False otherwise.
    """
    for key, template_value in template.items():
        # Check if required field exists
        if key not in data:
            if not isinstance(template_value, str) or "optional" not in template_value:
                return False
            continue

        data_value = data[key]

        # Handle nested dictionaries
        if isinstance(template_value, dict):
            if not isinstance(data_value, dict):
                return False
            if not validate_template_compatibility(template_value, data_value):
                return False

        # Handle lists
        elif isinstance(template_value, list):
            if not isinstance(data_value, list):
                return False
            # If template list has items, validate each data item against template item
            if template_value and data_value:
                template_item = template_value[0]
                for item in data_value:
                    if isinstance(template_item, dict):
                        if not validate_template_compatibility(template_item, item):
                            return False
                    # Additional type checking could be added here if needed

    return True

def merge_template_defaults(template: Dict[str, Any], data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Merge provided data with template defaults for optional fields.

    Args:
        template (Dict[str, Any]): Template structure generated by generate_json_template.
        data (Dict[str, Any]): Data to merge with template defaults.

    Returns:
        Dict[str, Any]: Merged data with template defaults for missing optional fields.
    """
    result = data.copy()

    for key, template_value in template.items():
        if key not in result:
            if isinstance(template_value, str) and "optional" in template_value:
                result[key] = None
            elif isinstance(template_value, dict):
                result[key] = {}
            elif isinstance(template_value, list):
                result[key] = []

        elif isinstance(template_value, dict) and isinstance(result[key], dict):
            result[key] = merge_template_defaults(template_value, result[key])

    return result